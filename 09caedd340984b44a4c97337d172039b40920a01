{
  "comments": [
    {
      "key": {
        "uuid": "5cb844e1_03465891",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2020-08-24T09:51:44Z",
      "side": 1,
      "message": "This is just the luma portion of RGB -\u003e YCbCr conversion.",
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2afc9ee8_f79728e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T17:16:41Z",
      "side": 1,
      "message": "LGTM",
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "792cd8c9_ed602bfa",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T11:31:20Z",
      "side": 1,
      "message": "I suspect I already mentioned this before and forgot. But do we want to worry about MSVC? I think we should. libjpeg-turbo supports MSVC 2005+.\n\nWe could do something like:\n#if defined(_MSC_VER)\n#define ALIGN(ALIGNMENT, THING) __declspec(align((ALIGNMENT))) (THING);\n#elif defined(__clang__) || defined(__GNUC__)\n#define ALIGN(ALIGNMENT, THING) (THING) __attribute__((aligned((ALIGNMENT))))\n#else\n#error \"Unknown compiler\"\n#endif\n\nBut surely libjpeg-turbo already has some sort of alignment macro, right?\nI\u0027m looking now and I don\u0027t see it. That...blows my mind. Surely I missed it?",
      "range": {
        "startLine": 61,
        "startChar": 16,
        "endLine": 61,
        "endChar": 43
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16f4a9df_6e4deb82",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2020-08-24T15:41:12Z",
      "side": 1,
      "message": "Looking through the previous patches, we didn\u0027t already discuss this - and we should probably make this work for all supported compilers.\n\nIs is quite mind-boggling that there is no alignment macro - the only mention of this kind of thing is here[1] for heap-allocations. Though to be fair, I can\u0027t find any statically allocated constant pools or such like outside of SIMD files - which either specify alignment directly in the asm, or make use of __attribute__(aligned()) in the case of PowerPC Altivec[2].\n\nI\u0027ll add the alignment macro to jpegint.h.\n\nGiven there\u0027s another instance that needs fixing[3], are you ok to land this as-is and I\u0027ll upload the alignment macro with appropriate changes to make use of it in the next CL? \n\n[1] https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/jmemmgr.c#L70\n[2] https://github.com/libjpeg-turbo/libjpeg-turbo/blob/6d8caa9f88184ad1698e91c94b37acb9506dacf0/simd/powerpc/jdcolext-altivec.c#L35\n[3] https://source.chromium.org/chromium/chromium/src/+/master:third_party/libjpeg_turbo/simd/arm/common/jidctint-neon.c;l\u003d78",
      "parentUuid": "792cd8c9_ed602bfa",
      "range": {
        "startLine": 61,
        "startChar": 16,
        "endLine": 61,
        "endChar": 43
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aea20584_f17545bb",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T17:16:41Z",
      "side": 1,
      "message": "Yeah, a future CL makes sense.",
      "parentUuid": "16f4a9df_6e4deb82",
      "range": {
        "startLine": 61,
        "startChar": 16,
        "endLine": 61,
        "endChar": 43
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55563550_a007f271",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T12:09:19Z",
      "side": 1,
      "message": "Also this is probably a silly question but I figure I should ask just to be sure.\n\nIn x86, the mul instruction (non-SIMD) stores the output in two registers. So you can get a 64-bit result of multiplying two 32-bit numbers. I see ARM SIMD vmull_n_u16 does that.\n\nBut we\u0027re expanding first.\n\nI *think* that is because there is no vmull_n_u8, right?\nOr maybe it is because we want the extra precision when doing the Y\u003dRGB conversion?",
      "range": {
        "startLine": 71,
        "startChar": 6,
        "endLine": 71,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f7bfbef_04d5ef76",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2020-08-24T15:41:12Z",
      "side": 1,
      "message": "This is to do with precision.\n\nThe conversion constants need to be 16-bit values to get the desired precision, and there are no (Arm) instructions that multiply an 8-bit value and a 16-bit value, that return a 32-bit result. (So we expand - note the expansion doesn\u0027t actually scale anything, rather just prepend 8 zeros to each element - from 8-bit elements to 16-bit elements first.)",
      "parentUuid": "55563550_a007f271",
      "range": {
        "startLine": 71,
        "startChar": 6,
        "endLine": 71,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7fb5a035_96584c00",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T17:16:41Z",
      "side": 1,
      "message": "Sounds good.",
      "parentUuid": "8f7bfbef_04d5ef76",
      "range": {
        "startLine": 71,
        "startChar": 6,
        "endLine": 71,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "991c7a08_1d3b6daf",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T11:31:20Z",
      "side": 1,
      "message": "I may have missed something earlier.\nWe aren\u0027t shifting this right? We\u0027re taking the lower 8 bits of y_l and y_h?",
      "range": {
        "startLine": 100,
        "startChar": 35,
        "endLine": 100,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4c3a2b5_86f6cded",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 1247893
      },
      "writtenOn": "2020-08-24T15:41:12Z",
      "side": 1,
      "message": "That\u0027s correct - there\u0027s no shift here, and we\u0027re taking the lower 8 bits of y_l and y_h.\n\nThe only scaling we had in this computation was the conversion constants being premultiplied by 2^16 - the rest of the multiplication is just the arithmetic that you see in the equation on line 78. We descaled Y by 2^16 on lines 93-96 so the result is already sat in the lower 8 bits of the 16-bit elements here.\n\nThere\u0027s no way this can overflow because 0.29900 + 0.58700 + 0.11400 \u003d 1. So even if R, G and B were all 255 (the maximum) the resulting Y would still only be 255.",
      "parentUuid": "991c7a08_1d3b6daf",
      "range": {
        "startLine": 100,
        "startChar": 35,
        "endLine": 100,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a3ebc52_ede72356",
        "filename": "simd/arm/common/jcgryext-neon.c",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 1189229
      },
      "writtenOn": "2020-08-24T17:16:41Z",
      "side": 1,
      "message": "Got it. Thank you. Perfect answer. :D",
      "parentUuid": "d4c3a2b5_86f6cded",
      "range": {
        "startLine": 100,
        "startChar": 35,
        "endLine": 100,
        "endChar": 44
      },
      "revId": "09caedd340984b44a4c97337d172039b40920a01",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}